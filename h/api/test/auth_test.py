# -*- coding: utf-8 -*-

import datetime

from jwt import InvalidTokenError
import mock
from pyramid import security
import pytest

from h.api import auth


@pytest.mark.parametrize("p_in,p_out", [
    # The basics
    ([], []),
    (['acct:donna@example.com'], ['acct:donna@example.com']),
    (['group:foo'], ['group:foo']),

    # Remove pyramid principals
    (['system.Everyone'], []),

    # Remap annotatator principal names
    (['group:__world__'], [security.Everyone]),
    (['group:__authenticated__'], [security.Authenticated]),

    # Normalise multiple principals
    (['me', 'myself', 'me', 'group:__world__', 'group:foo', 'system.Admins'],
     ['me', 'myself', security.Everyone, 'group:foo']),
])
def test_translate_annotation_principals(p_in, p_out):
    result = auth.translate_annotation_principals(p_in)

    assert set(result) == set(p_out)


generate_bearer_token_fixtures = pytest.mark.usefixtures('jwt')


@generate_bearer_token_fixtures
def test_generate_bearer_token_calls_encode(jwt):
    """It should pass the right arguments to encode()."""
    before = datetime.datetime.utcnow()
    request = mock_request()

    auth.generate_bearer_token(request, 3600)

    assert jwt.encode.call_args[0][0]['sub'] == 'acct:testuser@hypothes.is', (
        "It should encode the userid as 'sub'")
    after = datetime.datetime.utcnow() + datetime.timedelta(seconds=3600)
    assert before < jwt.encode.call_args[0][0]['exp'] < after, (
        "It should encode the expiration time as 'exp'")
    assert jwt.encode.call_args[0][0]['aud'] == request.host_url, (
        "It should encode request.host_url as 'aud'")
    assert jwt.encode.call_args[1]['algorithm'] == 'HS256', (
        "It should pass the right algorithm to encode()")


@generate_bearer_token_fixtures
def test_generate_bearer_token_when_authenticated_userid_is_None(jwt):
    """It should work when request.authenticated_userid is None."""
    request = mock_request()
    request.authenticated_userid = None

    auth.generate_bearer_token(request, 3600)

    assert jwt.encode.call_args[0][0]['sub'] is None


@generate_bearer_token_fixtures
def test_generate_bearer_token_returns_token(jwt):
    assert (auth.generate_bearer_token(mock_request(), 3600) ==
            jwt.encode.return_value)


user_id_from_bearer_token_fixtures = pytest.mark.usefixtures('jwt')


@user_id_from_bearer_token_fixtures
def test_userid_from_bearer_token_returns_None_if_no_Authorization_header():
    request = mock_request()
    request.headers = {}  # No 'Authorization' header.

    assert auth.userid_from_bearer_token(request) is None


@user_id_from_bearer_token_fixtures
def test_userid_from_bearer_token_calls_decode(jwt):
    request = mock_request(token='Bearer abc123')

    auth.userid_from_bearer_token(request)

    assert jwt.decode.call_args[0] == ('abc123',), (
        "It should pass the correct token to decode()")
    assert (jwt.decode.call_args[1]['key'] ==
            request.registry.settings['h.client_secret']), (
        "It should pass the right secret key to decode()")
    assert jwt.decode.call_args[1]['audience'] == request.host_url, (
        "It should pass the right audience to decode()")
    assert jwt.decode.call_args[1]['leeway'] == 240, (
        "It should pass the right leeway to decode()")
    assert jwt.decode.call_args[1]['algorithms'] == ['HS256'], (
        "It should pass the right algorithms to decode()")


@user_id_from_bearer_token_fixtures
def test_userid_from_bearer_token_returns_sub_from_decode(jwt):
    jwt.decode.return_value = {'sub': 'acct:test_user@hypothes.is'}

    result = auth.userid_from_bearer_token(mock_request(token='Bearer abc123'))

    assert result == 'acct:test_user@hypothes.is'


@user_id_from_bearer_token_fixtures
def test_userid_from_bearer_token_returns_None_if_no_sub(jwt):
    jwt.decode.return_value = {}  # No 'sub' key.

    result = auth.userid_from_bearer_token(mock_request(token='Bearer abc123'))

    assert result is None


@user_id_from_bearer_token_fixtures
def test_userid_from_bearer_token_returns_None_if_decoding_fails(jwt):
    jwt.decode.side_effect = InvalidTokenError

    result = auth.userid_from_bearer_token(mock_request(token='Bearer abc123'))

    assert result is None


def test_generate_bearer_token_userid_from_bearer_token_successful():
    """Test generate_bearer_token() and userid_from_bearer_token() together.

    Test that userid_from_bearer_token() successfully decodes tokens
    generated by generate_bearer_token().

    """
    token = auth.generate_bearer_token(mock_request(), 3600)
    userid = auth.userid_from_bearer_token(
        request=mock_request(token='Bearer ' + token))

    assert userid == 'acct:testuser@hypothes.is'


def test_generate_bearer_token_userid_from_bearer_token_bad_token():
    """Test generate_bearer_token() and userid_from_bearer_token() together.

    Test that userid_from_bearer_token() correctly fails to decode a token
    generated by generate_bearer_token() using the wrong secret.

    """
    request = mock_request()
    request.registry.settings['h.client_secret'] = 'wrong'
    token = auth.generate_bearer_token(request, 3600)

    userid = auth.userid_from_bearer_token(
        request=mock_request(token='Bearer ' + token))

    assert userid is None


def mock_request(token=None):
    request = mock.Mock(authenticated_userid='acct:testuser@hypothes.is',
                        host_url='https://hypothes.is')
    request.registry.settings = {
        'h.client_id': 'id',
        'h.client_secret': 'secret'
    }
    if token:
        request.headers = {'Authorization': token}
    return request


@pytest.fixture
def jwt(request):
    patcher = mock.patch('h.api.auth.jwt', autospec=True)
    module = patcher.start()
    request.addfinalizer(patcher.stop)
    return module
